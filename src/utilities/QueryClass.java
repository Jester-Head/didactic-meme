package utilities;

import controller.SignInScreen;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import model.Appointment;
import model.Customer;
import model.User;

import java.sql.*;
import java.time.*;
import java.time.format.DateTimeFormatter;

/**
 * Contains all database functionality.
 */
public class QueryClass {
	private static final ObservableList<Customer> customerObservableList = FXCollections.observableArrayList();
	private static final ObservableList<Appointment> appointmentObservableList = FXCollections.observableArrayList();
	private static final ObservableList<User> userObservableList = FXCollections.observableArrayList();

	public QueryClass() {
	}

	/**
	 * Queries all countries.
	 *
	 * @return ObservableList Of country names in the countries table.
	 */
	public static ObservableList<String> populateCountry() {

		ObservableList<String> countryNames = FXCollections.observableArrayList();

		try {
			String selectCountry = "Select Country FROM countries ";

			PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(selectCountry);
			ResultSet country = ps.executeQuery();
			while (country.next()) {
				countryNames.add(country.getString("Country"));
			}

		} catch (SQLException throwables) {
			throwables.printStackTrace();
		}
		return countryNames;
	}

	/**
	 * Queries first level divisions.
	 *
	 * @return ObservableList of region names located in the first_level_divisions table.
	 */
	public static ObservableList<String> populateDivision() {

		ObservableList<String> divisionNames = FXCollections.observableArrayList();

		try {
			String selectDivision = "SELECT Division FROM first_level_divisions ";

			PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(selectDivision);
			ResultSet division = ps.executeQuery();
			while (division.next()) {
				divisionNames.add(division.getString("Division"));
			}

		} catch (SQLException throwables) {
			throwables.printStackTrace();
		}
		return divisionNames;
	}

	/**
	 * Filters first_level_divisions by matching country.
	 *
	 * @param country user's selected country.
	 * @return ObservableList of filtered first_level_divisions
	 * @throws SQLException
	 */
	public static ObservableList<String> filterDivision(String country) throws SQLException {

		String filter = "Select fd.Division From first_level_divisions fd Join countries c On c.Country_ID = fd" +
				".COUNTRY_ID where Country = ?";
		ObservableList<String> divisions = FXCollections.observableArrayList();
		PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(filter);
		ps.setString(1, country);
		ResultSet rs = ps.executeQuery();
		while (rs.next()) {
			String division = rs.getString("Division");
			divisions.add(division);
		}
		return divisions;
	}

	/**
	 * Finds country name associated with specific region.
	 *
	 * @param divisions user's selected division.
	 * @return country name.
	 * @throws SQLException
	 */
	public static String filterCountry(String divisions) throws SQLException {
		String filter = "Select c.Country From countries c Join first_level_divisions fd On c.Country_ID=fd" +
				".COUNTRY_ID" +
				" where Division=?";
		String country = "";
		PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(filter);
		ps.setString(1, divisions);
		ResultSet rs = ps.executeQuery();
		while (rs.next()) {
			country = rs.getString("Country");
		}
		return country;
	}

	/**
	 * Inserts new customer data into database.
	 *
	 * @param newCustomer customer information collected from AddCustomer form.
	 */
	public static void insertCustomer(Customer newCustomer) {
		try {
			String insertCustomer = "INSERT INTO  customers VALUES(NULL,?,?,?,?,?,?,?,?,?)";
			//Gets database connection and retrieves autogenerated primary key for new customer
			PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(insertCustomer,
					PreparedStatement.RETURN_GENERATED_KEYS);

			String customerName = newCustomer.getCustomerName();
			String address = newCustomer.getCustomerAddress();
			String zipCode = newCustomer.getCustomerZip();
			String phone = newCustomer.getCustomerPhoneNumber();
			String createDate = String.valueOf(newCustomer.getCreateDate());
			String createdBy = newCustomer.getCreatedBy();
			String lastUpdate = String.valueOf(newCustomer.getUpdateTime());
			String updatedBy = newCustomer.getUpdatedBy();

			int divisionId = findDivisionId(newCustomer);

			ps.setString(1, customerName);
			ps.setString(2, address);
			ps.setString(3, zipCode);
			ps.setString(4, phone);
			ps.setString(5, createDate);
			ps.setString(6, createdBy);
			ps.setString(7, lastUpdate);
			ps.setString(8, updatedBy);
			ps.setInt(9, divisionId);


			//Executes Update
			ps.execute();
		} catch (SQLException throwables) {
			throwables.getMessage();
			//throwables.printStackTrace();
		}
	}

	/**
	 * Updates existing customer in database.
	 *
	 * @param customer information collected from UpdateCustomer form,
	 * @return number of rows affected.
	 * @throws SQLException
	 */
	public static int updateCustomer(Customer customer) throws SQLException {
		int customerId = customer.getCustomerId();

		int divisionId = QueryClass.findDivisionId(customer);
		String updateCustomer = " UPDATE customers SET Customer_Name = ?,Address = ?,Postal_Code = ?, Phone = ?," +
				"Last_Update = ?, Last_Updated_By = ?,Division_ID = ? WHERE Customer_ID" +
				" =?";
		PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(updateCustomer);
		String customerName = customer.getCustomerName();
		String address = customer.getCustomerAddress();
		String zipCode = customer.getCustomerZip();
		String phone = customer.getCustomerPhoneNumber();
		String createDate = String.valueOf(customer.getCreateDate());
		String createdBy = customer.getCreatedBy();
		String lastUpdate = String.valueOf(customer.getUpdateTime());
		String updatedBy = customer.getUpdatedBy();
		ps.setString(1, customerName);
		ps.setString(2, address);
		ps.setString(3, zipCode);
		ps.setString(4, phone);
		ps.setString(5, lastUpdate);
		ps.setString(6, updatedBy);
		ps.setInt(7, divisionId);
		ps.setInt(8, customerId);
		int results = ps.executeUpdate();

		return results;
	}

	/**
	 * Deletes customer and all of their appointments from the database.
	 *
	 * @param customer item selected from table.
	 */
	public static boolean deleteCustomer(Customer customer) {
		boolean results = true;
		int customerId = customer.getCustomerId();
		String deleteCustomer = "Delete from customers Where Customer_ID = ?";
		String deleteAppointments = "Delete from appointments Where Customer_ID = ?";
		try {
			PreparedStatement psa = DataBaseConnection.getConnection().prepareStatement(deleteAppointments);
			PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(deleteCustomer);
			ps.setInt(1, customerId);
			psa.setInt(1, customerId);
			psa.execute();
			results = ps.execute();

		} catch (SQLException throwables) {
			throwables.printStackTrace();
		}
		return results;
	}

	/**
	 * Queries all customers and first level divisions.
	 *
	 * @return ObservableList of customers and their location.
	 */
	public static ObservableList<Customer> getAllCustomers() {

		customerObservableList.clear();
		try {
			String queryCustomer = "SELECT c.Customer_ID, c.Customer_Name,CONCAT(c.Address, \", \", fd.Division)As " +
					"Address,c.Postal_Code,c.Phone, c.Create_Date,c.Created_By,c.Last_Update,c.Last_Updated_By,c" +
					".Division_ID From customers c Join first_level_divisions fd On c.Division_ID = fd.Division_ID";
			//Gets database connection
			PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(queryCustomer);
			//Executes Query
			ResultSet customerResults = ps.executeQuery();


			//Loops through results and adds Customer to the observable list
			while (customerResults.next()) {
				int customerId = customerResults.getInt("Customer_ID");
				String customerName = customerResults.getString("Customer_Name");
				String customerAddress = customerResults.getString("Address");
				String customerZip = customerResults.getString("Postal_Code");
				String customerPhoneNumber = customerResults.getString("Phone");
				Timestamp createDate = customerResults.getTimestamp("Create_Date");
				String createdBy = customerResults.getString("Created_By");
				Timestamp lastUpdate = customerResults.getTimestamp("Last_Update");
				String lastUpdatedBy = customerResults.getString("Last_Updated_By");
				//int divisionId = customerResults.getInt("Division_ID");
				Customer customer = new Customer(customerId, customerName, customerAddress, customerZip,
						customerPhoneNumber, createDate, createdBy, lastUpdate, lastUpdatedBy);
				addCustomer(customer);
			}

		} catch (SQLException throwable) {
			throwable.printStackTrace();
		}
		return customerObservableList;
	}

	/**
	 * Adds customer to an ObservableList that's used to populate customer records table.
	 *
	 * @param customer customer object.
	 */
	public static void addCustomer(Customer customer) {
		customerObservableList.add(customer);
	}

	/**
	 * Finds the division ID using the name of the division and country.
	 *
	 * @param customer division name field in customer class.
	 * @return division ID associated with division name.
	 */
	public static int findDivisionId(Customer customer) {
		String division = customer.getCustomerDivision();
		String country = customer.getCustomerCountry();
		String statement = "SELECT Division_ID FROM first_level_divisions fd JOIN countries c ON c.Country_ID = fd" +
				".COUNTRY_ID WHERE fd.Division = ? AND c.Country = ?";

		try {
			int divisionId = 0;
			PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(statement);
			ps.setString(1, division);
			ps.setString(2, country);
			//Executes Query
			ResultSet resultSet = ps.executeQuery();
			if (resultSet.next()) {
				divisionId = resultSet.getInt("Division_ID");
			}
			return divisionId;
		} catch (SQLException throwables) {
			//throwables.printStackTrace();
			throwables.getMessage();
		}
		return 0;
	}

	/**
	 * Queries and sets customer's Division and Country.
	 *
	 * @param customer customer information necessary to perform table joins.
	 */
	public static void setCustomerLocation(Customer customer) {

		int customerId = customer.getCustomerId();
		String queryDivision = "Select d.Division from first_level_divisions d  join customers cu on cu.Division_ID " +
				"=" +
				" " +
				"d.Division_ID join countries co on co.Country_ID = d.COUNTRY_ID where Customer_ID = ?";
		String queryCountry = "Select co.Country from countries co join first_level_divisions d on  co.Country_ID = " +
				"d" +
				".COUNTRY_ID join customers cu ON cu.Division_ID = d.Division_ID where Customer_ID = ?";

		try {
			PreparedStatement psd = DataBaseConnection.getConnection().prepareStatement(queryDivision);
			psd.setInt(1, customerId);
			ResultSet resultSetD = psd.executeQuery();
			resultSetD.next();
			customer.setCustomerDivision(resultSetD.getString("Division"));


			PreparedStatement psc = DataBaseConnection.getConnection().prepareStatement(queryCountry);
			psc.setInt(1, customerId);
			ResultSet resultSetC = psc.executeQuery();
			resultSetC.next();
			customer.setCustomerCountry(resultSetC.getString("Country"));

		} catch (SQLException throwables) {
			System.out.println(throwables.getMessage());
		}
	}


	//Appointment Queries and Helpers

	/**
	 * Converts time to UTC for uniform database storage.
	 *
	 * @param ts system's default time.
	 * @return Time in UTC
	 */
	public static Timestamp timeConversionUTC(Timestamp ts) {

		LocalDateTime ldt = ts.toLocalDateTime();
		ZonedDateTime zdt = ldt.atZone(ZoneId.of(ZoneId.systemDefault().toString()));
		ZonedDateTime utczdt = zdt.withZoneSameInstant(ZoneId.of("UTC"));
		LocalDateTime ldtIn = utczdt.toLocalDateTime();

		return Timestamp.valueOf(ldtIn);

	}

	/**
	 * Converts from UTC to the system's default timezone.
	 *
	 * @param ts time in UTC
	 * @return time in system's default time.
	 */
	public static Timestamp timeConversionLocal(Timestamp ts) {
		LocalDateTime ldtIn = ts.toLocalDateTime();
		ZonedDateTime zdtOut = ldtIn.atZone(ZoneId.of("UTC"));
		ZonedDateTime zdtToLocalTZ = zdtOut.withZoneSameInstant(ZoneId.of(ZoneId.systemDefault().toString()));
		LocalDateTime ldtOut = zdtToLocalTZ.toLocalDateTime();

		return Timestamp.valueOf(ldtOut);
	}

	/**
	 * Queries appointments within 15 minutes of login-in.
	 *
	 * @return ObservableList of upcoming appointments.
	 * @throws SQLException
	 */
	public static ObservableList<Appointment> getUpcomingAppointments() throws SQLException {

		ObservableList<Appointment> allAppointments = FXCollections.observableArrayList();
		int activeUser = SignInScreen.getActiveUser().getUserID();
		Timestamp soon =
				Timestamp.valueOf(String.valueOf(timeConversionUTC(Timestamp.valueOf(LocalDateTime.now().plusMinutes(15)))));
		Timestamp now = Timestamp.valueOf(String.valueOf(timeConversionUTC(Timestamp.valueOf(LocalDateTime.now()))));

		PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement("Select * From appointments Where" +
				" " +
				"Start Between ? And ? And User_ID = ? ");

		ps.setTimestamp(1, now);
		ps.setTimestamp(2, soon);
		ps.setInt(3, activeUser);

		ResultSet rs = ps.executeQuery();

		while (rs.next()) {
			// get data from the returned rows
			int appointmentID = rs.getInt("Appointment_ID");
			String title = rs.getString("Title");
			String description = rs.getString("Description");
			String location = rs.getString("Location");
			String type = rs.getString("Type");
			Timestamp startDateTime = rs.getTimestamp("Start");
			Timestamp endDateTime = rs.getTimestamp("End");
			Timestamp lastUpdated = rs.getTimestamp("Last_Update");
			String lastUpdatedBy = rs.getString("Last_Updated_By");
			int customerID = rs.getInt("Customer_ID");
			int userID = rs.getInt("User_ID");
			int contactID = rs.getInt("Contact_ID");

			Appointment appointment = new Appointment(appointmentID, title, description, location, type, startDateTime
					, endDateTime, lastUpdated, lastUpdatedBy, contactID, customerID, userID);

			allAppointments.add(appointment);

		}
		return allAppointments;

	}

	/**
	 * Queries all appointments
	 *
	 * @return ObservableList of appointments.
	 */
	public static ObservableList<Appointment> getAllAppointments() {
		appointmentObservableList.clear();
		String findApp = "SELECT * FROM appointments a Left Outer Join contacts as c ON a.Contact_ID = c.Contact_ID";

		try {
			PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(findApp);
			ResultSet rs = ps.executeQuery();

			while (rs.next()) {
				int appointmentId = rs.getInt("Appointment_ID");
				String title = rs.getString("Title");
				String description = rs.getString("Description");
				String location = rs.getString("Location");
				String appointmentType = rs.getString("Type");
				int customerId = rs.getInt("Customer_ID");

				Timestamp startDateTime = rs.getTimestamp("Start");
				Timestamp startTS = timeConversionLocal(startDateTime);


				Timestamp endDateTime = rs.getTimestamp("End");
				Timestamp endTS = timeConversionLocal(endDateTime);


				Timestamp createDate = timeConversionLocal(rs.getTimestamp("Create_Date"));

				String createdBy = rs.getString("Created_By");
				Timestamp lastUpdate = timeConversionLocal(rs.getTimestamp("Last_Update"));
				String updatedBy = rs.getString("Last_Updated_By");


				int contactId = rs.getInt("Contact_ID");
				int userId = rs.getInt("User_ID");
				String contactName = rs.getString("Contact_Name");
				String contactEmail = rs.getString("Email");


				Appointment appointment = new Appointment(appointmentId, title, description, location, appointmentType
						, startTS, endTS, createDate, createdBy, lastUpdate, updatedBy, contactId, contactName,
						customerId, userId);
				appointment.setContactEmail(contactEmail);
				addAppointment(appointment);


			}

		} catch (SQLException throwables) {
			throwables.printStackTrace();
		}
		return appointmentObservableList;
	}

	/**
	 * Adds appointment to an ObservableList which is used to populate the appointments TableView.
	 *
	 * @param newAppointment appointment information from controller class.
	 */
	public static void addAppointment(Appointment newAppointment) {
		appointmentObservableList.add(newAppointment);
	}

	/**
	 * Updates existing appointment in the database.
	 *
	 * @param appointment appointment information gathered from controller class.
	 */
	public static boolean updateAppointment(Appointment appointment) {
		//appointmentObservableList.clear();


		String updateAppointment = "Update appointments Set Title=?,Description=?,Location=?," +
				"Type=?,Start=?,End=?,Last_Update=?,Last_Updated_By=?,Customer_ID=?," +
				"User_ID=?,Contact_ID=? Where Appointment_ID = ?";

		try {
			PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(updateAppointment);
			int appointmentID = appointment.getAppointmentId();
			String appointmentTitle = appointment.getTitle();
			String description = appointment.getDescription();
			String location = appointment.getLocation();
			String appointmentType = appointment.getAppointmentType();

			Timestamp startTime = timeConversionUTC(appointment.getStartDateTime());

			Timestamp endTime = timeConversionUTC(appointment.getEndDateTime());

			Timestamp lastUpDate = timeConversionUTC(appointment.getLastUpdate());
			int userId = appointment.getUserId();
			int customerId = appointment.getCustomerId();
			int contactId = appointment.getContactId();
			String updatedBy = appointment.getUpdatedBy();


			ps.setString(1, appointmentTitle);
			ps.setString(2, description);
			ps.setString(3, location);
			ps.setString(4, appointmentType);
			ps.setTimestamp(5, startTime);
			ps.setTimestamp(6, endTime);
			ps.setTimestamp(7, lastUpDate);
			ps.setString(8, updatedBy);
			ps.setInt(9, customerId);
			ps.setInt(10, userId);
			ps.setInt(11, contactId);
			ps.setInt(12, appointmentID);

			ps.execute();
			return true;
		} catch (SQLException throwables) {
			throwables.printStackTrace();
			return false;
		}


	}

	/**
	 * Inserts new appointment in the database.
	 *
	 * @param appointment appointment information from controller class.
	 */
	public static void insertAppointment(Appointment appointment) {
		appointmentObservableList.clear();
		String addAppointment = "Insert Into appointments VALUES(NULL,?,?,?,?,?,?,?,?,?,?,?,?,?)";
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

		try {
			PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(addAppointment,
					PreparedStatement.RETURN_GENERATED_KEYS);
			String appointmentTitle = appointment.getTitle();
			String description = appointment.getDescription();
			String location = appointment.getLocation();
			String appointmentType = appointment.getAppointmentType();

			Timestamp startTime = timeConversionUTC(appointment.getStartDateTime());
			Timestamp endTime = timeConversionUTC(appointment.getEndDateTime());
			Timestamp createDate = timeConversionUTC(appointment.getCreateDate());
			Timestamp lastUpDate = timeConversionUTC(appointment.getLastUpdate());


			int userId = appointment.getUserId();
			int customerId = appointment.getCustomerId();
			int contactId = appointment.getContactId();

			String createdBy = appointment.getCreatedBy();
			String updatedBy = appointment.getUpdatedBy();

			ps.setString(1, appointmentTitle);
			ps.setString(2, description);
			ps.setString(3, location);
			ps.setString(4, appointmentType);
			ps.setTimestamp(5, startTime);
			ps.setTimestamp(6, endTime);
			ps.setTimestamp(7, createDate);
			ps.setString(8, createdBy);
			ps.setTimestamp(9, lastUpDate);
			ps.setString(10, updatedBy);
			ps.setInt(11, customerId);
			ps.setInt(12, userId);
			ps.setInt(13, contactId);

			ps.execute();


		} catch (SQLException throwables) {
			throwables.printStackTrace();
		}


	}

	/**
	 * Deletes appointment from the database.
	 *
	 * @param appointment item selected from table.
	 */
	public static boolean deleteAppointment(Appointment appointment) {
		boolean results = true;
		int appointmentId = appointment.getAppointmentId();
		String deleteAppointments = "Delete from appointments Where Appointment_ID = ?";
		try {
			PreparedStatement psa = DataBaseConnection.getConnection().prepareStatement(deleteAppointments);
			psa.setInt(1, appointmentId);
			results = psa.execute();


		} catch (SQLException throwables) {
			throwables.printStackTrace();
		}


		return results;
	}

	/**
	 * Queries all appointments scheduled within the current month.
	 *
	 * @return ObservableList appointments.
	 */
	public static ObservableList<Appointment> getMonthlyAppointments() {
		appointmentObservableList.clear();
		String monthly = "Select * From appointments a Left Outer Join contacts c On a.Contact_ID = c.Contact_ID " +
				"Where" +
				" (MONTH(Start)=MONTH(now()) and YEAR(Start)=YEAR(now()))";
		try {
			PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(monthly);
			ResultSet rs = ps.executeQuery();
			while (rs.next()) {
				int appointmentId = rs.getInt("Appointment_ID");
				String title = rs.getString("Title");
				String description = rs.getString("Description");
				String location = rs.getString("Location");
				String appointmentType = rs.getString("Type");
				int customerId = rs.getInt("Customer_ID");


				ZoneId systemDefault = ZoneId.systemDefault();

				LocalDateTime startDateTime = rs.getTimestamp("Start").toLocalDateTime();
				ZonedDateTime zdtStart = startDateTime.atZone(ZoneId.of("UTC"));
				ZonedDateTime newLocalStart = zdtStart.withZoneSameInstant(systemDefault);
				Timestamp startTS = Timestamp.valueOf(newLocalStart.toLocalDateTime());


				LocalDateTime endDateTime = rs.getTimestamp("End").toLocalDateTime();
				ZonedDateTime zdtEnd = endDateTime.atZone(ZoneId.of("UTC"));
				ZonedDateTime newLocalEnd = zdtEnd.withZoneSameInstant(systemDefault);
				Timestamp endTS = Timestamp.valueOf(newLocalEnd.toLocalDateTime());

				Timestamp createDate = rs.getTimestamp("Create_Date");
				String createdBy = rs.getString("Created_By");
				Timestamp lastUpdate = rs.getTimestamp("Last_Update");
				String updatedBy = rs.getString("Last_Updated_By");


				int contactId = rs.getInt("Contact_ID");
				int userId = rs.getInt("User_ID");
				String contactName = rs.getString("Contact_Name");
				String contactEmail = rs.getString("Email");

				Appointment appointment = new Appointment(appointmentId, title, description, location, appointmentType
						, startTS, endTS, createDate, createdBy, lastUpdate, updatedBy, contactId, contactName,
						customerId, userId);
				appointment.setContactEmail(contactEmail);
				addAppointment(appointment);

			}
		} catch (SQLException throwables) {
			throwables.printStackTrace();
		}

		return appointmentObservableList;
	}

	/**
	 * Queries all appointments scheduled within the current week.
	 *
	 * @return ObservableList appointments.
	 */
	public static ObservableList<Appointment> getWeeklyAppointments() {
		appointmentObservableList.clear();
		String monthly = "Select * From appointments a Left Outer Join contacts c On a.Contact_ID = c.Contact_ID " +
				"Where" +
				" (Week(Start)=Week(now()) and YEAR(Start)=YEAR(now()))";
		try {
			PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(monthly);
			ResultSet rs = ps.executeQuery();
			while (rs.next()) {
				int appointmentId = rs.getInt("Appointment_ID");
				String title = rs.getString("Title");
				String description = rs.getString("Description");
				String location = rs.getString("Location");
				String appointmentType = rs.getString("Type");
				int customerId = rs.getInt("Customer_ID");


				ZoneId systemDefault = ZoneId.systemDefault();

				LocalDateTime startDateTime = rs.getTimestamp("Start").toLocalDateTime();
				ZonedDateTime zdtStart = startDateTime.atZone(ZoneId.of("UTC"));
				ZonedDateTime newLocalStart = zdtStart.withZoneSameInstant(systemDefault);
				Timestamp startTS = Timestamp.valueOf(newLocalStart.toLocalDateTime());


				LocalDateTime endDateTime = rs.getTimestamp("End").toLocalDateTime();
				ZonedDateTime zdtEnd = endDateTime.atZone(ZoneId.of("UTC"));
				ZonedDateTime newLocalEnd = zdtEnd.withZoneSameInstant(systemDefault);
				Timestamp endTS = Timestamp.valueOf(newLocalEnd.toLocalDateTime());

				Timestamp createDate = rs.getTimestamp("Create_Date");
				String createdBy = rs.getString("Created_By");
				Timestamp lastUpdate = rs.getTimestamp("Last_Update");
				String updatedBy = rs.getString("Last_Updated_By");


				int contactId = rs.getInt("Contact_ID");
				int userId = rs.getInt("User_ID");
				String contactName = rs.getString("Contact_Name");
				String contactEmail = rs.getString("Email");

				Appointment appointment = new Appointment(appointmentId, title, description, location, appointmentType
						, startTS, endTS, createDate, createdBy, lastUpdate, updatedBy, contactId, contactName,
						customerId, userId);
				appointment.setContactEmail(contactEmail);
				addAppointment(appointment);

			}
		} catch (SQLException throwables) {
			throwables.printStackTrace();
		}
		return appointmentObservableList;
	}

	//Contacts

	/**
	 * Queries all contacts.
	 *
	 * @return ObservableList of contacts.
	 */
	public static ObservableList<Appointment> queryContacts() {
		ObservableList<Appointment> contacts = FXCollections.observableArrayList();
		String searchContacts = "Select * from contacts";
		try {
			PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(searchContacts);
			ResultSet rs = ps.executeQuery();
			while (rs.next()) {
				String contactName = rs.getString("Contact_Name");
				int contactId = rs.getInt("Contact_ID");
				String contactEmail = rs.getString("Email");
				Appointment appointment = new Appointment(contactId, contactName, contactEmail);
				contacts.add(appointment);
			}
		} catch (SQLException throwables) {
			throwables.printStackTrace();
		}
		return contacts;
	}

	/**
	 * Gathers all information on contact.
	 *
	 * @param contactId id pulled from contact ComboBox.
	 * @return Appointment contact info.
	 */
	public static Appointment getContactInfo(int contactId) {
		String email = "";
		String name = "";
		String lookupContact = "Select * From contacts Where Contact_ID = ?";
		try {
			PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(lookupContact);
			ps.setInt(1, contactId);
			ResultSet rs = ps.executeQuery();
			rs.next();
			email = rs.getString("Email");
			name = rs.getString("Contact_Name");


		} catch (SQLException throwables) {
			throwables.printStackTrace();
		}


		return new Appointment(contactId, name, email);
	}


	//Users

	/**
	 * Queries all users in the database.
	 *
	 * @return ObservableList users.
	 */
	public static ObservableList<User> getAllUsers() throws SQLException {
		String queryUser = "Select * From users";
		PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(queryUser);

		ResultSet rs = ps.executeQuery();
		String userName = rs.getString("User_Name");
		int userId = rs.getInt("User_ID");
		String password = rs.getString("Password");

		User user = new User(userId, userName, password);
		userObservableList.add(user);
		return userObservableList;
	}

	/**
	 * Queries the user who's currently logged in.
	 * @param activeUserId user currently logged in.
	 * @return User logged in user.
	 */
	public static User lookupUser(int activeUserId) throws SQLException {
		String userSearch = "Select * From users Where User_ID = ?";

		PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(userSearch);
		ps.setInt(1, activeUserId);
		ResultSet rs = ps.executeQuery();
		String userName = rs.getString("User_Name");
		int userId = rs.getInt("User_ID");
		String password = rs.getString("Password");

		User user = new User(userId, userName);
		return user;
	}

	/**
	 * Queries the user who's attempting to log-in.
	 *
	 * @param userName active user
	 * @param password user password
	 * @return User logged in user.
	 */
	public static User lookupUser(String userName, String password) throws SQLException {
		String userSearch = " Select * From users Where User_Name = ?" +
				" " +
				"And Password = ?";


		PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(userSearch);
		ps.setString(1, userName);
		ps.setString(2, password);

		ResultSet rs = ps.executeQuery();
		while (rs.next()) {
			int userID = rs.getInt("User_ID");

			User user = new User(userID, userName, password);
			return user;
		}
		return new User(0, null, null);
	}

	// Reports

	/**
	 * Queries selected contact's appointments.
	 * @param contactId contact ID associated with appointment ID.
	 * @return ObservableList appointments
	 * @throws SQLException
	 */
	public static ObservableList<Appointment> getContactAppointments(int contactId) throws SQLException {
		appointmentObservableList.clear();
		String contactSchedule = "Select c.Contact_ID,c.Contact_Name,a.Appointment_ID,a.Title,a.Description,a.Type,a" +
				".Start,a.End,a.Customer_ID From appointments a Right Outer Join contacts c on a.Contact_ID = c" +
				".Contact_ID Where c.Contact_ID = ?";

		PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(contactSchedule);
		ps.setInt(1, contactId);
		ResultSet rs = ps.executeQuery();
		while (rs.next()) {
			int appointmentId = rs.getInt("Appointment_ID");
			String title = rs.getString("Title");
			String description = rs.getString("Description");
			String appointmentType = rs.getString("Type");
			int customerId = rs.getInt("Customer_ID");


			LocalDateTime startDateTime = rs.getTimestamp("Start").toLocalDateTime();
			ZonedDateTime zdtStart = startDateTime.atZone(ZoneId.of("UTC"));
			ZonedDateTime newLocalStart = zdtStart.withZoneSameInstant(ZoneId.systemDefault());
			startDateTime = newLocalStart.toLocalDateTime();
			Timestamp startTS = Timestamp.valueOf(startDateTime);


			LocalDateTime endDateTime = rs.getTimestamp("End").toLocalDateTime();
			ZonedDateTime zdtEnd = endDateTime.atZone(ZoneId.of("UTC"));
			ZonedDateTime newLocalEnd = zdtEnd.withZoneSameInstant(ZoneId.systemDefault());
			Timestamp endTS = Timestamp.valueOf(newLocalEnd.toLocalDateTime());

			Appointment appointment = new Appointment(appointmentId, title, description, appointmentType
					, startTS, endTS, customerId);
			appointmentObservableList.add(appointment);

		}
		return appointmentObservableList;
	}

	/**
	 * Queries appointments in the given time frame and counts how many there are of each type.
	 *
	 * @param year  selected year.
	 * @param month selected month
	 * @return ObservableList appointments
	 */
	public static ObservableList<Appointment> getAppointmentTypeCount(int year, int month) throws SQLException {
		ObservableList<Appointment> typeCount = FXCollections.observableArrayList();
		String test = "Select Monthname(Start) AS Month, Type, Count(Type) AS Count From appointments Where Month" +
				"(Start)=? And year(Start)=? group by Month, Type ";


		PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(test);
		ps.setInt(1, month);
		ps.setInt(2, year);

		ResultSet rs = ps.executeQuery();
		while (rs.next()) {
			String monthName = rs.getString("Month");
			String type = rs.getString("Type");
			int count = rs.getInt("Count");
			Appointment typeAppointment = new Appointment();
			typeAppointment.setAppointmentType(type);
			typeAppointment.setTypeCount(count);
			typeCount.add(typeAppointment);

		}

		return typeCount;
	}

	/**
	 * Queries each the number of appointments each contact has or had in a given time frame.
	 *
	 * @param year  selected year.
	 * @param month selected month.
	 * @return ObservableList appointments
	 */
	public static ObservableList<Appointment> getContactAppointmentCount(int year, int month) throws SQLException {
		ObservableList<Appointment> contactCount = FXCollections.observableArrayList();

		String test = "Select Monthname(Start) AS Month,c.Contact_ID,c.Contact_Name,c.Email,COUNT(a.Appointment_ID) " +
				"As" +
				" Count From appointments a Left Outer Join contacts c on c.Contact_ID=a.Contact_ID Where Month " +
				"(Start)=? And year(Start)=? group by Month,Contact_ID; ";


		PreparedStatement ps = DataBaseConnection.getConnection().prepareStatement(test);
		ps.setInt(1, month);
		ps.setInt(2, year);

		ResultSet rs = ps.executeQuery();
		while (rs.next()) {
			String monthName = rs.getString("Month");
			int contactId = rs.getInt("Contact_ID");
			String contactName = rs.getString("Contact_Name");
			String email = rs.getString("Email");
			int count = rs.getInt("Count");
			Appointment contactAppointment = new Appointment(contactId, contactName, email);
			contactAppointment.setAppointmentCount(count);
			contactCount.add(contactAppointment);

		}
		return contactCount;
	}

}